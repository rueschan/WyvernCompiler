/*
  Wyvern compiler - Common Intermediate Language (CIL) code generator.
  Copyright (C) 2013 Ariel Ortiz, ITESM CEM
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;
using System.Collections.Generic;

namespace Wyvern
{

  class CILGenerator
  {

    SymbolTable globals;
    FunctionSymbolTable functions;

    int labelCounter = 0;
    bool isGlobals = false;
    bool inFunction = false;
    KeyValuePair<string, FunctionTable> row = new KeyValuePair<string, FunctionTable>();

    //-----------------------------------------------------------
    string GenerateLabel()
    {
      return String.Format("${0:000000}", labelCounter++);
    }

    //-----------------------------------------------------------

    public CILGenerator(SymbolTable globals, FunctionSymbolTable functions)
    {
      this.globals = globals;
      this.functions = functions;
    }

    public string Visit(Program node)
    {
      return "// Code generated by the wyvern compiler.\n\n"
        + ".assembly 'wyvern' {}\n\n"
        + ".assembly extern 'wyvernlib' {}\n\n"
        + ".class public 'WyvernProgram' extends "
        + "['mscorlib']'System'.'Object'\n"
        + "\t{\n"
        + Visit((dynamic)node[0])
        + "}\n";
    }

    ////-----------------------------------------------------------
    public string Visit(DefList node)
    {
      var sb = new StringBuilder();
      sb.Append(VisitChildren(node));
      return sb.ToString();
    }

    ////-----------------------------------------------------------
    public string Visit(VarDef node)
    {
			var sb = new StringBuilder();
      if (inFunction)
      {
        // The code for the local variable declarations is 
        // generated directly from the symbol table, not from 
        // the AST nodes.
        foreach (var entry in row.Value.funsymtable)
        {
          sb.Append(String.Format(
                  "\t\t.locals init ({0} '{1}')\n",
                  "int32",
                  entry.Key)
                );
        }
        sb.Append("\t}\n\n");

        isGlobals = true;
        return sb.ToString();
      }

      if (isGlobals) return "";

      // The code for the local variable declarations is 
      // generated directly from the symbol table, not from 
      // the AST nodes.
      foreach (var entry in globals)
      {
        sb.Append(String.Format(
                "\t\t.locals init ({0} '{1}')\n",
                "int32",
                entry.Key)
              );
      }
      sb.Append("\t}\n\n");

      isGlobals = true;
      return sb.ToString();
    }

    ////-----------------------------------------------------------
    public string Visit(FunDef node)
    {
      inFunction = true;
      row = functions[node.AnchorToken.Lexeme];

      // The code for the local variable declarations is 
      // generated directly from the symbol table, not from 
      // the AST nodes.
      var sb = new StringBuilder();
      sb.Append("\t.method public static hidebysig\n");
      sb.Append(String.Format(
          "\t\tdefault int32 {0} (",
          node.AnchorToken.Lexeme)
      );
      sb.Append(Visit((dynamic)node[0]));
      sb.Append(") cil managed\n\t{\n");
      if (node.AnchorToken.Lexeme == "main")
        sb.Append("\t\t.entrypoint\n");
      sb.Append("\t\t.maxstack 16\n");
      // sb.Append(Visit((dynamic)node[1]));	// VarDefList
      // sb.Append(Visit((dynamic)node[2]));	// StmtList
      // Return
      sb.Append("\t\tldc.i4.0\n");
      sb.Append("\t\tret\n\t}\n\n");

      inFunction = false;
      return sb.ToString();
    }

    ////-----------------------------------------------------------
    public string Visit(ParamList node)
    {
      // This method is never called.
      return "";
    }

    ////-----------------------------------------------------------
    public string Visit(IdList node)
    {
      var sb = new StringBuilder();

      for (int i = 0; i < node.CountChildren(); i++)
      {
        if (i != node.CountChildren() - 1)
        {
          sb.Append("int32 " + node[i].AnchorToken.Lexeme + ", ");
        }
        else
        {
          sb.Append("int32 " + node[i].AnchorToken.Lexeme);
        }
      }
      return sb.ToString();
    }

    ////-----------------------------------------------------------
    //public string Visit(Declaration node)
    //{
    //	// This method is never called.
    //	return null;
    //}

    ////-----------------------------------------------------------
    //public string Visit(StatementList node)
    //{
    //	return VisitChildren(node);
    //}

    ////-----------------------------------------------------------
    //public string Visit(Assignment node)
    //{
    //	return Visit((dynamic)node[0])
    //		+ "\t\tstloc '"
    //		+ node.AnchorToken.Lexeme
    //		+ "'\n";
    //}

    ////-----------------------------------------------------------
    //public string Visit(Print node)
    //{
    //	return Visit((dynamic)node[0])
    //		+ "\t\tcall void class ['bcuplib']'Buttercup'."
    //		+ "'Utils'::'Print'("
    //		+ CILTypes[node.ExpressionType]
    //		+ ")\n";
    //}

    ////-----------------------------------------------------------
    //public string Visit(If node)
    //{

    //	var label = GenerateLabel();

    //	return String.Format(
    //		"{1}\t\tbrfalse '{0}'\n{2}\t'{0}':\n",
    //		label,
    //		Visit((dynamic)node[0]),
    //		Visit((dynamic)node[1])
    //	);
    //}

    ////-----------------------------------------------------------
    public string Visit(Identifier node)
    {
      return "\t\tldloc '"
        + node.AnchorToken.Lexeme
        + "'\n";
    }

    ////-----------------------------------------------------------
    //public string Visit(IntLiteral node)
    //{

    //	var intValue = Convert.ToInt32(node.AnchorToken.Lexeme);

    //	if (intValue <= 8)
    //	{
    //		return "\t\tldc.i4."
    //			+ intValue
    //			+ "\n";

    //	}
    //	else if (intValue <= 127)
    //	{
    //		return "\t\tldc.i4.s "
    //			+ intValue
    //			+ "\n";

    //	}
    //	else
    //	{
    //		return "\t\tldc.i4 "
    //			+ intValue
    //			+ "\n";
    //	}
    //}

    ////-----------------------------------------------------------
    //public string Visit(True node)
    //{
    //	return "\t\tldc.i4.1\n";
    //}

    ////-----------------------------------------------------------
    //public string Visit(False node)
    //{
    //	return "\t\tldc.i4.0\n";
    //}

    ////-----------------------------------------------------------
    //public string Visit(Neg node)
    //{
    //	return "\t\tldc.i4.0\n"
    //		+ Visit((dynamic)node[0])
    //		+ "\t\tsub.ovf\n";
    //}

    ////-----------------------------------------------------------
    //public string Visit(And node)
    //{
    //	return VisitBinaryOperator("and", node);
    //}

    ////-----------------------------------------------------------
    //public string Visit(Less node)
    //{
    //	return VisitBinaryOperator("clt", node);
    //}

    ////-----------------------------------------------------------
    //public string Visit(Plus node)
    //{
    //	return VisitBinaryOperator("add.ovf", node);
    //}

    ////-----------------------------------------------------------
    //public string Visit(Mul node)
    //{
    //	return VisitBinaryOperator("mul.ovf", node);
    //}

    ////-----------------------------------------------------------
    string VisitChildren(Node node)
    {
      var sb = new StringBuilder();
      foreach (var n in node)
      {
        sb.Append(Visit((dynamic)n));
      }
      return sb.ToString();
    }

    ////-----------------------------------------------------------
    //string VisitBinaryOperator(string op, Node node)
    //{
    //	return Visit((dynamic)node[0])
    //		+ Visit((dynamic)node[1])
    //		+ "\t\t"
    //		+ op
    //		+ "\n";
    //}
  }
}
